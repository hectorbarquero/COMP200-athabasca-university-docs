.. I'm on 103/148 right now
.. I have not submitted the challenge work yet
.. an assignment is required for chapter 3 "Assignment 1 â€“ choose ONE exercise each from Chapters 2 and 3"
.. assignment not submitted yet.


Unit one, section three
++++++++++++++++++++++++

    *"nothing to see here yet. Currently working"*


General reading notes
======================

* It's possible that you can use the right algorithm, but to the wrong problem.
* Mismatching an algorithm to a problem is one of the most common causes of an incorrect algorithm.
* It's important to ask "are we solving the right problem? are we solving the problem right?".
* Algorithms aren't intended for academic interest. They're meant to be used.
* A great deal of time goes into program maintenance.
* Usually, the person who has to correct the program and maintain it isn't the one who originally wrote the program.
* It's important to make algorithms clear and easy to understand for this reason.
* *Elegance* is the algorithmic equivalent to *style*.
* A computer scientist should be watchful of resourses and performance. If two algorithms solve a problem, the one which consumes fewer resources and is more performant is the correct algorithm.
* *Efficiency* is the term used to describe the care and use of computing resources.
* *Space efficiency* is judged by the amount of information an algorithm stores in the memory, in addition to initial input data.
* If you try to measure algorithm efficiency with a stop watch, you'd be measuring hardware and not the algorithm itself.
* It's not to say that the stop watch method is useless. You can do benchmarking with this technique.
* To measure algorithm efficiency, we check the amount of work the algorithm takes, independent of the hardware.
* The stufy of algorithmic efficiency is called *analysis of algorithms*.
* Sequential search algorithms aren't efficient for large values of *n*. Best case 1, worst case *n*, average case *n/2*.
* A sequential search algorithm stores only a few peripheral variables, which is small in comparison to the value of *n*. It's space efficient.
* A peripheral value is constant and doesn't really matter in terms of the space efficiency calculations because of *order of magnitude*. If c = constant, and n = number of data, then the total work is c(n). This means the peripheral work is constant and scales with the throughput.
* Order of magnitude of n is written as O(n), and it's anything with a constant that scales irrelevant to the input linearly, since the constant is so insignificant to the time efficiency, it's discarded.
* For linear search, the algorithm equation to calculate average case is roughly half but the real equation is much more complicated than that. Use n / 2 for now.
* The selection sort algorithm performs a sort of a list, and it *grows* a sorted subsection of the list from the back to the front.
* 

*Notes are ongoing, pending completion*


The efficiency of algorithms
=============================


Practice problem A
~~~~~~~~~~~~~~~~~~~~
Currently working. Check back soon. 
.. Gaus formula, page 94

Practice problem B 
~~~~~~~~~~~~~~~~~~~~
Currently working. Check back soon. 
.. practice problem on page 101

Practice problem C
~~~~~~~~~~~~~~~~~~~~
Currently working. Check back soon. 



Challenge work submission
===========================

1. Read chapter three of the textbook.
2. Locate an resource which discusses attributes of algorithms discussedin chapter 3. Post a link with a brief review.


.. note:: 
   Finding a link.


Pending completion


Works cited
~~~~~~~~~~~~

Pending completion


Assignment 1 (chapter one, section three)
==========================================
.. this is technically part 2/2 for assignment 1. The first part is in the previous chapter, unitOneSectionTwo.rst